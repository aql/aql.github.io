<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/css/home.css" />
    <title>Perlによる日本語コード変換のメモ（第二版）</title>
  </head>
  <body>
<h1 id="perl">Perlによる日本語コード変換のメモ（第二版）</h1>

<div class="navigation">
  <a href="/">hikoboshi.home</a>
  /
  Perlによる日本語コード変換のメモ（第二版）
</div>

<p>前に書いたときと時代背景も知識も大幅に違うので、書き直してみることにしました。Perl 5.8以降を前提として考えます。</p>

<h2>この文章で書く（つもりの）こと</h2>

<ul>
<li>use utf8環境での、文字セットの考え方</li>
<li>発生しがちな文字化けとその原因</li>
<li>解決のヒント</li>
</ul>

<h2 id="jcode.pl">jcode.pl時代の文字セットの扱い</h2>

<p>まずは、<a href="http://www.srekcah.org/jcode/">jcode.pl</a>などが全盛だった時代を思い出してみます。jcode.plの時代は、Unicodeはほぼ使われておらず、JIS, Shift_JIS, EUC_JPあたりの変換を行う事が主でした。実際のコードを見て、扱われ方を考察してみましょう。</p>

<pre><code>#!/usr/bin/perl
# jcode.plを用いたコード変換
require 'jcode.pl';

open my $r, '&lt;sjis.txt';
open my $w, '&gt;euc.txt';
while(my $data = &lt;$r&gt;){
    jcode::convert(*data, 'euc');
    print $w $data;
}
close $w;
close $r;
exit;
</code></pre>

<p>この例では、dataの中をeucに変えている訳ですが、変換処理自体はjcode.plが行っているのみで、それだけの話です。dataの中はオクテット列であり、Perlも単なるオクテット列として扱っています。</p>

<h2 id="utf8">utf8時代の考え方</h2>

<p><a href="http://search.cpan.org/perldoc/Encode">Encode.pm</a>、あるいはuse <a href="http://search.cpan.org/perldoc/utf8">utf8</a>全盛時代（そんなのがあるかは別として）では、上記のような考え方が一新されています。この、一新された考え方を理解しておく事こそが、へんてこな文字化けを回避する、あるいは解決するコツになります。</p>

<p>まず、use utf8すると、Perlは文字列を「内部表現」という形で扱うことになります。「内部表現」は、「utf8フラグ」がついたutf8の文字列です。これまで（jcode.pl時代には）Perlは外から来た文字列をただのオクテット列として扱っていて不干渉でしたが、use utf8を行うと、<strong>「文字列」をそれ以外と区別した特別なものとして扱う</strong>という事です。</p>

<p>そこで、外で使う文字列と、「内部表現」との変換が必要になります。Encode.pmをuseすると使えるようになる、encodeやdecodeは、そういった内部表現とのやり取りをする関数になります。</p>

<p>ちょっと図示してみましょう。外から取得した文字列を変換して、また外に出力するものを考えます。</p>

<p>まずはjcode.pl時代の考え方です。</p>

<pre><code>文字列（オクテット列） -&gt; jcode::convert -&gt; 文字列（オクテット列）
</code></pre>

<p>一方、utf8時代では、</p>

<pre><code>文字列（オクテット列） -&gt; decode -&gt; 文字列（内部表現） -&gt; encode -&gt; 文字列（オクテット列）
</code></pre>

<p>コードにしてみると、jcode.plの場合</p>

<pre><code>jcode:convert( *var, 'euc' );
print $var;
</code></pre>

<p>一方encode/decodeの場合は</p>

<pre><code>my $string = decode( 'shiftjis', $var );
print encode( 'euc-jp', $string );
</code></pre>

<p>あるいは短く</p>

<pre><code>print encode( 'euc-jp', decode( 'shiftjis', $var ) );
</code></pre>

<p>encodeやらdecodeが、感覚と逆になっていると感じた事はないでしょうか。もし感じたことがあるなら、暗黙に「内部表現に」「内部表現から」というモノが隠れている事を覚えておくと良いでしょう。</p>

<p>というわけで、use utf8している環境では、内部表現と外が明確に分かれています。このルールを侵犯して、内部表現のまま出力しようとすると、「Wide charactor in ...」といったwarningで知らせてくれます。</p>

<h2 id="openperlio">3変数openとPerlIOレイヤー</h2>

<p>上記の考え方をもとにすれば、3変数openやらなんやらといった新しい構文でやっていることも自ずと理解出来ます。3変数openでは、<strong>openする際に予めオクテット列と内部表現の変換ルールを指定してある</strong>ということです。</p>

<pre><code>#!/usr/bin/perl
# Encode.pmを用いたコード変換
use Encode;

open my $r, '&lt;:encoding(shiftjis)', 'sjis.txt';
open my $w, '&gt;:encoding(euc-jp)', 'euc.txt';
while(my $data = &lt;$r&gt;){
    print $w $data;
}
close $w;
close $r;
exit;
</code></pre>

<p>openの時点で変換ルールが決まっているので、decodeやencodeを挟まなくても、そのまま内部表現として利用することが出来、さらに出力時も自動変換されます。このとき実際に変換処理を担当しているのがPerlIOレイヤーと呼ばれるものです。</p>

<pre><code>文字列（オクテット列） -&gt; PerlIOレイヤー -&gt; 文字列（内部表現） -&gt; PerlIOレイヤー -&gt; 文字列（オクテット列）
</code></pre>

<p>3変数openはopen時にIOレイヤーを決め、binmodeではあとからレイヤーを変更する事が出来ます。再三登場する、入出力の間に１枚噛んでいるようすが、Perlにおける多言語処理の考え方をよく表していると言えるでしょう。</p>

<h2>内部表現の利点</h2>

<p>わざわざ内部表現にするのは、面倒な事ばかりのようですが、もちろん良いこともあります。</p>

<p>例えば「１文字」を数えられるようになります。これまでは正規表現などを使い、うまいことやって「１文字」を数えたりしていましたが、内部表現にしておけば、それがutf8の文字列である事は約束されているので、「うまいこと」やる必要はありません。（そもそもlengthとかで返ってくるのが「文字数」になります。バイト数を数えたいときには余計なお世話ですが。）</p>

<p>また、正規表現なども多バイト文字をそのまま使えます。Perlコード中に埋め込まれるリテラルもすべて内部表現として扱われているので、日本語だろうとなんだろうと、そのまま書けばそのまま動くということになるのです。とても普通の事ですが、これまでは結構面倒なこともありましたよね。<strong>あの厄介で非直感的な、文字境界を考慮した正規表現だとかなんだとかとは、もうおさらばです。</strong></p>

<h2>自動アップグレード</h2>

<p>さて、基本的には上記の考えを飲み込んでおけばOKなのですが、とっても親切かつ厄介な機能があります。「自動アップグレード」です。</p>

<p>例えば、内部表現になっている文字列と、ただのオクテット列を連結するときなどに、これが起きます。</p>

<pre><code>utf8::is_utf8( $utf8 );   # =&gt; 1
utf8::is_utf8( $octets ); # =&gt; 0
# このとき
$mixed = $utf8 . $octets;
utf8::is_utf8( $mixed );  # =&gt; 1
</code></pre>

<p>当然と言えば当然なのですが、このアップグレードの際には、オクテット列が実際のところいったい何の文字セットであったかは考慮されません。というと優しいですが、実際には <strong>強引にlatin-1だと考えて変換してしまいます</strong>。このために、盛大に文字化けが発生する訳です。</p>

<p>ほんの一つの変数の影響で、出力全体がおかしくなるといった事もよく起きます。utf8フラグが疎まれるのも、ルールに則っていない変数がたった一つ入り込むだけで、破壊的な結果をもたらすからだと思われます。何せ全て化けたりするので、ショックが大きいものです。</p>

<h2>文字化け発生時の対処</h2>

<p>文字化けが起きたら、最初に疑うのが上記の自動アップグレードです。ほぼ99%、何かしらルールを無視する変数が紛れているので、これを突き止めるのが基本的な対処方法になります。</p>

<p>突き止める方法は、地道に変数をダンプして調べるしかありません。変数が文字列（内部表現）かそうでないかは、utf8パッケージに含まれるis_utf8関数を使用して調べることが出来ます。</p>

<pre><code>utf8::is_utf8( $utf8 );   # =&gt; 1
utf8::is_utf8( $octets ); # =&gt; 0
</code></pre>

<p>原因となる変数を特定出来たら、あとはそれをどうにかするだけです。「どうにか」にもいろいろあり、自分で触れる範囲ならばきちんとルールに従うように修正する、修正不能なモジュールの中とかならdecodeやutf8::upgradeなどを使って連結前にフラグを調整する、といったことを行います。</p>

<h2>文字セットの推定</h2>

<p>少し話が変わります。</p>

<p>jcode.plやJcode.pmでは、とにかく文字列を投げ込んでやればいい感じに判定して変換してくれましたが、encode/decodeでは関数の引数に文字セットを指定しているので、推定どうするんだって話になるかもしれません。文字セットの推定は、<a href="http://search.cpan.org/perldoc/Encode::Guess">Encode::Guess</a>モジュールを使います。ちょっとここにも抜粋しておきます。</p>

<pre><code>use Encode;
use Encode::Guess qw( euc-jp shiftjis 7bit-jis );
print encode( "euc-jp", decode( 'Guess', $input ) );
</code></pre>

<p>あるいはguess_encoding関数がexportされているので、これを使うと推定結果をオブジェクトとして取得することが出来ます。</p>

<pre><code>my $guess = guess_encoding($input, qw/euc-jp shiftjis 7bit-jis/);
</code></pre>

<p>ところで、Encodeの文字セット指定は、これまで（Jcode.pmやjcode.pl）とはちょっと違っているので気をつけましょう。日本語なら<a href="http://search.cpan.org/perldoc/Encode::JP">Encode::JP</a>のperldocに書いてあります。</p>

<h2 id="jcode.pm">Jcode.pm</h2>

<p>最後にJcode.pmのこともちょっとだけ触れておきます。</p>

<p>現行のJcode.pmはEncode.pmのラッパーになっていますが、次のような事をする場合</p>

<pre><code>Jcode-&gt;new($string)-&gt;utf8;
</code></pre>

<p>結果は内部表現ではなくてオクテット列です。</p>

<p>なので、encodeの代わりには使えますが、decodeの代わりには（そのままでは）ならないという事は、覚えておいた方が良いかも。そのかわり、encode/decodeの場合はひと手間必要だった文字コードの推定を、Jcodeは自動でやってくれるので、その辺は便利ですね。もちろん、推定しなくてもわかっているなら、指定しておいた方が安全です。</p>

<p>どうでもいいけどコンストラクタのエイリアスとしてjcode関数がexportされるので、それを使って書くとほんのちょっと気持ちいいです。</p>

<pre><code>jcode($string)-&gt;utf8;
</code></pre>

<p>ただ、Jcodeは内部的にeucで持っているらしいところがちょっと気になるんですが…詳しく調べてない。誰かに聞きゃ良いんだけど。</p>

<h2>まとめ</h2>

<p>まとめとしては、次のようなものでしょうか。</p>

<ul>
<li>外から持ってきたオクテット列は内部表現に</li>
<li>外に出すときは内部表現からオクテット列に</li>
<li>文字化けする時は変換漏れがある</li>
</ul>

<p>Perlでの多言語処理では、これが「たった一つの冴えたやりかた」です。この考え方をきちんと頭に入れ、そして徹底する事が、問題解決のキーになるでしょう。</p>

<h2>おまけ</h2>

<p>前の文章を書いていた頃は、思えばまだ<a href="http://www.hatena.ne.jp/">はてな</a>に入社していないどころかそれよりずっと前で、オブジェクト指向すら良く分かってなかったです。当時は懐かしい感じのPerl/CGIコードしか書けず、utf8まわりには盛大にハマりました。よくもまぁ頑張ったものだ。というわけで、前の文章は要するに「若気の至り」な文章でした。読み返してみると、なかなか紆余曲折していて、当時の混乱が目に浮かぶようです。</p>

<p>今だと、より良い解説はたくさんあるので、これまで放置していましたが、意外とここがブックマークされていたりとかして、いつかどうにかしなきゃなぁと感じていました。ということで、YAPC::Asia 2009があるので、併せて書き直してみた次第です。</p>

<p>何かの参考になれば幸いです。</p>

<h2>履歴</h2>

<dl>
  <dt>2009.09.08</dt>
  <dd>第二版</dd>

  <dt>2005.06.08</dt>
  <dd>メンテナンス</dd>

  <dt>2004.07.31</dt>
  <dd><a href="/perl/doc/encode_old.html">初版</a></dd>
</dl>

    <footer>
      &copy; 2015 Hikoboshi-Softworks.com
    </footer>
  </body>
</html>
